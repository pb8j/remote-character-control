<!DOCTYPE html>
<html>
<head>
    <title>Mobile View (3D Robot Arm)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 90vw;
            height: 90vh;
            max-width: 800px;
            max-height: 600px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #2c3e50, #34495e); /* Canvas background is here */
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 15px; /* Matches container for rounded corners */
        }
        
        #cameraContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            display: none; /* Controlled by JS */
            z-index: 100;
        }
        
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #messageBox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 1001;
            display: none;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-size: 1.2em;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p>Loading 3D Robot Arm...</p>
    </div>
    
    <div id="container">
        <div id="threejs-container"></div>
        <div id="cameraContainer">
            <video id="cameraFeed" autoplay playsinline muted></video>
        </div>
    </div>
    
    <div id="messageBox"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <!-- Official Three.js STLLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            if (msgBox) {
                msgBox.textContent = message;
                msgBox.style.display = 'block';
                setTimeout(() => {
                    msgBox.style.display = 'none';
                }, duration);
            } else {
                console.warn('MessageBox element not found!');
            }
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // --- Socket.IO Setup ---
        const FLASK_SOCKET_URL = 'https://remote-character-control.onrender.com';
        console.log(`Mobile View: Connecting to: ${FLASK_SOCKET_URL}`);
        const socket = io(FLASK_SOCKET_URL);

        // --- Camera Setup ---
        let cameraStream = null;
        let cameraActive = false;
        let cameraFrameInterval = null; // To store the interval ID

        async function startCamera() {
            console.log("Mobile View: Attempting to start camera.");
            if (cameraActive) {
                console.log("Mobile View: Camera already active.");
                return;
            }

            try {
                const video = document.getElementById('cameraFeed');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 320 },
                        height: { ideal: 240 },
                        facingMode: 'environment' // Use back camera if available
                    }
                });
                
                video.srcObject = stream;
                cameraStream = stream;
                cameraActive = true;
                
                document.getElementById('cameraContainer').style.display = 'block';
                showMessage('Camera started', 2000);
                
                // Start sending frames after video is ready to play
                video.addEventListener('loadeddata', () => {
                    if (!cameraFrameInterval) { // Prevent multiple intervals
                        cameraFrameInterval = setInterval(captureAndSendFrame, 100); // Send frame every 100ms
                    }
                }, { once: true }); // Ensure this listener only runs once
                
            } catch (error) {
                console.error('Mobile View: Error accessing camera:', error);
                let errorMessage = 'Camera access denied or not available.';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'Camera permission denied. Please enable in browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage = 'No camera found on this device.';
                }
                showMessage(errorMessage, 5000);
            }
        }

        function stopCamera() {
            console.log("Mobile View: Stopping camera.");
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraActive = false;
                
                const video = document.getElementById('cameraFeed');
                video.srcObject = null; // Disconnect the stream from the video element
                
                document.getElementById('cameraContainer').style.display = 'none';
                showMessage('Camera stopped', 2000);

                if (cameraFrameInterval) {
                    clearInterval(cameraFrameInterval);
                    cameraFrameInterval = null;
                }
            }
        }

        function captureAndSendFrame() {
            if (!cameraActive || !cameraStream) return;
            
            const video = document.getElementById('cameraFeed');
            // Create a temporary canvas for capturing the frame
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || 320; // Use video actual dimensions or fallback
            canvas.height = video.videoHeight || 240;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataURL = canvas.toDataURL('image/jpeg', 0.7); // 0.7 quality for speed
            const base64 = dataURL.split(',')[1];
            
            socket.emit('mobile_camera_frame', { frame: base64 });
        }

        // --- Socket Events for Camera ---
        socket.on('start_camera', () => {
            console.log('Mobile View: Received start camera command');
            startCamera();
        });

        socket.on('stop_camera', () => {
            console.log('Mobile View: Received stop camera command');
            stopCamera();
        });

        // --- Three.js Setup ---
        let scene, camera, renderer;
        let robotBaseGroup; // This group will hold the entire robot for overall X/Y movement
        let jointObjects = {}; // To store references to THREE.Group objects representing joints
        let linkObjects = {}; // To store references to THREE.Mesh objects representing links

        const MAX_X_POSITION_CLIENT = 900; // Consistent with app.py
        const URDF_SCALE = 1000; // URDF typically uses meters. If your models are in mm, use 1. If in meters, use 1000 for mm.
                                 // A 10cm x 10cm x 15cm base_link would be 100x100x150 in mm.
                                 // Adjust this scale to fit your scene and model export units.
                                 // Let's try a smaller scale for initial visibility, e.g., 500 for a robot of ~0.5m
                                 // Or even 100 for a robot ~10cm tall in THREE.js units.
                                 // Based on your URDF, a scale of 1000 means 0.081m becomes 81 units (mm).
                                 // This makes the robot quite large. Let's try 500.
                                 // I'll revert to 1000 if it's too small, as the URDF dimensions are in meters.

        // Helper to convert URDF rpy (roll, pitch, yaw) to Three.js Euler angles
        function rpyToEuler(r, p, y) {
            // URDF rpy is roll, pitch, yaw. Three.js Euler constructor is (x, y, z) corresponding to roll, pitch, yaw
            // The default order 'XYZ' is common for URDF.
            return new THREE.Euler(r, p, y, 'XYZ');
        }

        // --- Model Loading Helper ---
        // Using the official STLLoader from the CDN
        const stlLoader = new THREE.STLLoader();

        function loadSTL(path, material = new THREE.MeshPhongMaterial({ color: 0x606060 })) {
            return new Promise((resolve, reject) => {
                console.log(`Mobile View: Loading STL: ${path}`);
                stlLoader.load(
                    path,
                    function (geometry) {
                        const mesh = new THREE.Mesh(geometry, material);
                        // Enable shadows for each loaded mesh
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        resolve(mesh);
                    },
                    function (xhr) {
                        // console.log(`${path}: ${(xhr.loaded / xhr.total * 100).toFixed(2)}% loaded`);
                    },
                    function (error) {
                        console.error('Mobile View: An error occurred loading STL:', path, error);
                        reject(error);
                    }
                );
            });
        }

        async function initThreeJS() {
            console.log("Mobile View: initThreeJS called.");
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2c3e50); // Dark blue-gray background from CSS
                console.log("Mobile View: Scene created.");

                const container = document.getElementById('threejs-container');
                if (!container) {
                    console.error('Mobile View: THREE.JS CRITICAL: Container #threejs-container NOT found!');
                    showMessage('3D scene failed: Missing container element.', 7000);
                    return;
                }

                // Camera setup - Adjusted for a potentially smaller robot
                const aspect = container.clientWidth / container.clientHeight;
                const frustumSize = 100; // Adjusted for a typical robot arm size in scene units
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                     frustumSize * aspect / 2,
                     frustumSize / 2,
                    -frustumSize / 2,
                    1, 1000
                );
                camera.position.set(50, 50, 150); // Position camera to see robot from front-top
                camera.lookAt(0, 25, 0); // Look at a point above the ground where the base would be
                console.log("Mobile View: Camera created.");

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true; // Enable shadows
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
                
                container.appendChild(renderer.domElement);
                console.log("Mobile View: Renderer appended to container.");

                // Enhanced lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50); // Position light
                directionalLight.castShadow = true; // Light casts shadows
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                console.log("Mobile View: Lights added.");

                // Ground plane
                const planeGeometry = new THREE.PlaneGeometry(500, 500);
                const planeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x34495e, // Darker blue-gray
                    transparent: true,
                    opacity: 0.8
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                plane.position.y = -0.1; // Slightly below y=0 to avoid z-fighting
                plane.receiveShadow = true; // Plane receives shadows
                scene.add(plane);
                console.log("Mobile View: Ground plane added.");

                showMessage("Loading robot model, please wait...");
                await createReactorRobot(); // AWAIT THE ASYNC FUNCTION
                console.log("Mobile View: Reactor robot created.");

                window.addEventListener('resize', onWindowResize, false);
                console.log("Mobile View: Resize listener added.");

                animate();
                console.log("Mobile View: Animation loop started.");
                hideLoadingOverlay(); // Hide loading overlay when everything is ready
                showMessage("3D robot arm loaded successfully!", 3000);
                
            } catch (error) {
                console.error("Mobile View: CRITICAL ERROR initializing Three.js:", error);
                hideLoadingOverlay();
                showMessage("Failed to load 3D scene or robot: " + error.message, 10000);
            }
        }


        // --- Function to create the Reactor Robot by loading STL meshes ---
        async function createReactorRobot() {
            console.log("Mobile View: createReactorRobot called.");

            robotBaseGroup = new THREE.Group(); // This group represents the overall robot's base position
            // Add robotBaseGroup to the scene at the end of this function after all parts are loaded
            
            // Define materials based on your URDF colors if possible, otherwise reasonable defaults
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x404040, shininess: 50 }); // Dark gray
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 50 }); // Medium gray
            const jointMaterial = new THREE.MeshPhongMaterial({ color: 0xe74c3c, shininess: 80 }); // Red/Orange for joints
            const gripperMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 50 }); // Light gray

            // --- Load Links and Build Hierarchy ---
            // The URDF "package://" path needs to be mapped to a real HTTP path.
            const STL_BASE_PATH = 'https://remote-character-control.onrender.com/static/meshes/'; 
            console.log(`Mobile View: Using STL_BASE_PATH: ${STL_BASE_PATH}`);

            try {
                // Link: base_link
                const baseLinkMesh = await loadSTL(STL_BASE_PATH + 'base_link.STL', baseMaterial);
                baseLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE); // Apply global scale
                // The base_link visual origin is "0 0 0" in URDF, but its COM is at 0.04262 (42.62mm).
                // If the STL model is centered on its own geometry, it needs to be offset to align with the URDF origin for the parent joint.
                // Assuming base_link.STL's local origin is at its center bottom (0,0,0) and it's built upwards.
                // If your STL is exported centered at its geometric center, you might need an offset like (0, (model_height/2) * URDF_SCALE, 0)
                baseLinkMesh.position.set(0, 0, 0); // Position relative to robotBaseGroup (which is at Y=0)
                linkObjects['base_link'] = baseLinkMesh;
                robotBaseGroup.add(baseLinkMesh);


                // Joint: shoulder_yaw (revolute, axis z)
                // origin xyz="0 0 0.081" relative to base_link (0.081m = 81mm)
                // Its parent is base_link. Joint Group is placed at origin of joint relative to parent link.
                const shoulderYawJointGroup = new THREE.Group();
                shoulderYawJointGroup.position.set(0, 0, 0.081 * URDF_SCALE); // 81mm along Z from base_link (assuming base_link's local Z is its vertical axis for simplicity)
                // URDF: axis xyz="0 0 1" (Z-axis rotation for yaw)
                jointObjects['shoulder_yaw'] = shoulderYawJointGroup;
                baseLinkMesh.add(shoulderYawJointGroup); // Attach to base_link mesh


                // Link: shoulder_link
                // Attached to shoulder_yaw joint. Its origin in URDF is 0 0 0 relative to joint.
                const shoulderLinkMesh = await loadSTL(STL_BASE_PATH + 'shoulder_link.STL', jointMaterial);
                shoulderLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                shoulderLinkMesh.position.set(0, 0, 0); // Relative to its parent joint group's origin
                linkObjects['shoulder_link'] = shoulderLinkMesh;
                shoulderYawJointGroup.add(shoulderLinkMesh);


                // Joint: shoulder_pitch (revolute, axis y)
                // origin xyz="0 0 0.0265" relative to shoulder_link (26.5mm)
                const shoulderPitchJointGroup = new THREE.Group();
                shoulderPitchJointGroup.position.set(0, 0.0265 * URDF_SCALE, 0); // From shoulder_link, 26.5mm along Y
                // URDF: axis xyz="0 1 0" (Y-axis rotation for pitch)
                jointObjects['shoulder_pitch'] = shoulderPitchJointGroup;
                shoulderLinkMesh.add(shoulderPitchJointGroup);


                // Link: bicep_link
                const bicepLinkMesh = await loadSTL(STL_BASE_PATH + 'bicep_link.STL', armMaterial);
                bicepLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // URDF visual origin xyz="0 0 0", but inertial origin is offset.
                // The joint origin is where this link attaches. We want the mesh to be positioned
                // relative to the joint's frame correctly.
                // Assuming the mesh's visual is primarily along the X-axis for URDF, and then pitched.
                // Given the URDF origin is -0.079, 0.00175, 0.0073486. Let's try to negate this for the mesh.
                bicepLinkMesh.position.set(
                    -0.079312 * URDF_SCALE,
                    0.00175 * URDF_SCALE,
                    0.0073486 * URDF_SCALE
                );
                linkObjects['bicep_link'] = bicepLinkMesh;
                shoulderPitchJointGroup.add(bicepLinkMesh);


                // Joint: elbow_pitch (revolute, axis y)
                // origin xyz="-0.1445 0 0.0385" relative to bicep_link
                const elbowPitchJointGroup = new THREE.Group();
                elbowPitchJointGroup.position.set(-0.1445 * URDF_SCALE, 0, 0.0385 * URDF_SCALE);
                // URDF: axis xyz="0 1 0" (Y-axis rotation for pitch)
                jointObjects['elbow_pitch'] = elbowPitchJointGroup;
                bicepLinkMesh.add(elbowPitchJointGroup);


                // Link: forearm_link
                const forearmLinkMesh = await loadSTL(STL_BASE_PATH + 'forearm_link.STL', armMaterial);
                forearmLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to elbow_pitch joint
                forearmLinkMesh.position.set(0, 0, 0);
                linkObjects['forearm_link'] = forearmLinkMesh;
                elbowPitchJointGroup.add(forearmLinkMesh);


                // Joint: wrist_pitch (revolute, axis y)
                // origin xyz="0.1535 0 0" relative to forearm_link
                const wristPitchJointGroup = new THREE.Group();
                wristPitchJointGroup.position.set(0.1535 * URDF_SCALE, 0, 0);
                // URDF: axis xyz="0 1 0" (Y-axis rotation for pitch)
                jointObjects['wrist_pitch'] = wristPitchJointGroup;
                forearmLinkMesh.add(wristPitchJointGroup);


                // Link: wrist_1
                const wrist1LinkMesh = await loadSTL(STL_BASE_PATH + 'wrist_1.STL', jointMaterial);
                wrist1LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to wrist_pitch joint
                wrist1LinkMesh.position.set(0, 0, 0);
                linkObjects['wrist_1'] = wrist1LinkMesh;
                wristPitchJointGroup.add(wrist1LinkMesh);


                // Joint: wrist_roll (revolute, axis x)
                // origin xyz="0.071 0.00175 0" relative to wrist_1
                const wristRollJointGroup = new THREE.Group();
                wristRollJointGroup.position.set(0.071 * URDF_SCALE, 0.00175 * URDF_SCALE, 0);
                // URDF: axis xyz="1 0 0" (X-axis rotation for roll)
                jointObjects['wrist_roll'] = wristRollJointGroup;
                wrist1LinkMesh.add(wristRollJointGroup);


                // Link: wrist_2 (gripper base)
                const wrist2LinkMesh = await loadSTL(STL_BASE_PATH + 'wrist_2.STL', gripperMaterial);
                wrist2LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to wrist_roll joint
                wrist2LinkMesh.position.set(0, 0, 0);
                linkObjects['wrist_2'] = wrist2LinkMesh;
                wristRollJointGroup.add(wrist2LinkMesh);


                // Joint: finger_joint (Prismatic, axis z)
                // origin xyz="0.088882 -0.0187500 0.0012072" relative to wrist_2
                // rpy="1.5708 -1.5572 -3.1416"
                const finger1JointGroup = new THREE.Group();
                finger1JointGroup.position.set(0.088882 * URDF_SCALE, -0.0187500 * URDF_SCALE, 0.0012072 * URDF_SCALE);
                finger1JointGroup.rotation.copy(rpyToEuler(1.5708, -1.5572, -3.1416)); // Apply fixed RPY rotation for the joint's frame
                jointObjects['finger_joint'] = finger1JointGroup;
                wrist2LinkMesh.add(finger1JointGroup);

                // Link: finger_link_1 (moves with finger_joint)
                const finger1LinkMesh = await loadSTL(STL_BASE_PATH + 'finger_link.STL', gripperMaterial); // Reusing finger_link for both
                finger1LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                finger1LinkMesh.position.set(0,0,0); // This position will be translated by applyJointAngle along its local axis
                linkObjects['finger_link_1'] = finger1LinkMesh;
                finger1JointGroup.add(finger1LinkMesh);


                // Joint: finger_joint_2 (Prismatic, mimics finger_joint)
                // origin xyz="0.088882 0.0187500 0.0012072" relative to wrist_2
                // rpy="1.5708 1.5572 -1.4508E-15"
                const finger2JointGroup = new THREE.Group();
                finger2JointGroup.position.set(0.088882 * URDF_SCALE, 0.0187500 * URDF_SCALE, 0.0012072 * URDF_SCALE);
                finger2JointGroup.rotation.copy(rpyToEuler(1.5708, 1.5572, -1.4508e-15)); // Apply fixed RPY rotation for the joint's frame
                jointObjects['finger_joint_2'] = finger2JointGroup;
                wrist2LinkMesh.add(finger2JointGroup);

                // Link: finger_link_2
                const finger2LinkMesh = await loadSTL(STL_BASE_PATH + 'finger_link.STL', gripperMaterial);
                finger2LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                finger2LinkMesh.position.set(0,0,0); // This position will be translated by applyJointAngle along its local axis
                linkObjects['finger_link_2'] = finger2LinkMesh;
                finger2JointGroup.add(finger2LinkMesh);


                // Add the entire robot group to the scene after all parts are assembled
                scene.add(robotBaseGroup);
                console.log("Mobile View: All robot parts loaded and assembled.");
                console.log("Mobile View: jointObjects:", jointObjects);
                console.log("Mobile View: linkObjects:", linkObjects);

            } catch (error) {
                console.error("Mobile View: Error assembling robot from STL files:", error);
                showMessage("Error loading robot parts. Check console & STL file paths.", 10000);
            }
        }

        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            } else {
                console.warn("Mobile View: Renderer, scene, or camera not fully initialized for animation. Stopping animate loop.");
            }
        }

        function onWindowResize() {
            const container = document.getElementById('threejs-container');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 100; // Keep consistent

            camera.left   = -frustumSize * aspect / 2;
            camera.right  =  frustumSize * aspect / 2;
            camera.top    =  frustumSize / 2;
            camera.bottom = -frustumSize / 2;

            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            console.log(`Mobile View: Window resized: Renderer set to ${renderer.domElement.width}x${renderer.domElement.height}`);
        }

        // --- Character Base Movement Sync (for overall robot position) ---
        socket.on('character_moved', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when character_moved received. Model might still be loading.");
                return;
            }
            // Map server X (0-900) to Three.js X (centered around 0, +/- 450)
            const scaledX = position.x - (MAX_X_POSITION_CLIENT / 2);
            // Server Y position directly maps to Three.js Y. The base of the robot is assumed to be at Y=0 initially.
            const scaledY = position.y; 
            
            robotBaseGroup.position.x = scaledX;
            robotBaseGroup.position.y = scaledY; // Y position on ground
            console.log(`Mobile View: Robot base moved (server pos: ${position.x},${position.y}) -> (3D pos: ${robotBaseGroup.position.x.toFixed(2)},${robotBaseGroup.position.y.toFixed(2)})`);
        });

        socket.on('gravity', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when gravity received. Model might still be loading.");
                return;
            }
            const targetY = position.y; // Target Y position for the base

            const startY = robotBaseGroup.position.y;
            const duration = 300;
            const startTime = performance.now();

            function animateFall(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                robotBaseGroup.position.y = startY + (targetY - startY) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    robotBaseGroup.position.y = targetY;
                }
            }
            requestAnimationFrame(animateFall);
            console.log(`Mobile View: Gravity applied. Falling to Y: ${targetY}`);
        });


        // --- Socket Event for Joint Angle Updates ---
        socket.on('initial_joint_states', (jointStates) => {
            console.log('Mobile View: Received initial joint states:', jointStates);
            for (const jointName in jointStates) {
                if (jointObjects.hasOwnProperty(jointName)) {
                    applyJointAngle(jointName, jointStates[jointName]);
                } else {
                    console.warn(`Mobile View: Initial state for unknown joint received: ${jointName}`);
                }
            }
        });

        socket.on('joint_angle_updated', (data) => {
            console.log(`Mobile View: Received joint update: ${data.joint_name}, angle: ${data.angle}`);
            if (jointObjects.hasOwnProperty(data.joint_name)) {
                applyJointAngle(data.joint_name, data.angle);
            } else {
                console.warn(`Mobile View: Update for unknown joint received: ${data.joint_name}`);
            }
        });

        // --- Function to apply joint angles to Three.js objects ---
        function applyJointAngle(jointName, angle) {
            const jointGroup = jointObjects[jointName];
            if (!jointGroup) {
                console.error(`Mobile View: Attempted to move non-existent joint group: ${jointName}`);
                return;
            }

            // Apply rotation based on URDF axis and joint type
            switch (jointName) {
                case 'shoulder_yaw':
                    jointGroup.rotation.z = angle; // URDF axis: 0 0 1 (Z-axis)
                    break;
                case 'shoulder_pitch':
                    jointGroup.rotation.y = angle; // URDF axis: 0 1 0 (Y-axis)
                    break;
                case 'elbow_pitch':
                    jointGroup.rotation.y = angle; // URDF axis: 0 1 0 (Y-axis)
                    break;
                case 'wrist_pitch':
                    jointGroup.rotation.y = angle; // URDF axis: 0 1 0 (Y-axis)
                    break;
                case 'wrist_roll':
                    jointGroup.rotation.x = angle; // URDF axis: 1 0 0 (X-axis)
                    break;
                case 'finger_joint':
                    // Prismatic joint: moves the finger links along their local Z axis
                    // The 'angle' value is a linear position (0 to 0.014m in URDF)
                    if (linkObjects['finger_link_1']) {
                        // This moves the finger mesh along its local Z-axis (as defined by finger1JointGroup's orientation)
                        linkObjects['finger_link_1'].position.z = angle * URDF_SCALE;
                    }
                    if (linkObjects['finger_link_2']) {
                        // The other finger moves in the opposite direction
                        linkObjects['finger_link_2'].position.z = -angle * URDF_SCALE;
                    }
                    break;
                case 'finger_joint_2': // Mimics finger_joint, handled by finger_joint case
                    break;
                default:
                    console.warn(`Mobile View: No direct application for joint: ${jointName}`);
            }
            renderer.render(scene, camera); // Re-render after joint change
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Mobile View: DOMContentLoaded event fired. Initializing Three.js...");
            initThreeJS();
        });

        // Socket connection events
        socket.on('connect', () => {
            console.log('Mobile View: Connected to server');
            showMessage('Connected to server', 2000);
        });

        socket.on('disconnect', () => {
            console.log('Mobile View: Disconnected from server');
            showMessage('Disconnected from server', 3000);
        });
        socket.on('connect_error', (error) => {
            console.error('Mobile View: Socket connection error:', error);
            showMessage('Connection error: ' + error.message, 5000);
        });
    </script>
</body>
</html>
