<!DOCTYPE html>
<html>
<head>
    <title>Mobile View (3D Robot Arm)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 90vw;
            height: 90vh;
            max-width: 800px;
            max-height: 600px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        canvas {
            display: block;
            background: linear-gradient(45deg, #2c3e50, #34495e);
            width: 100%;
            height: 100%;
            border-radius: 15px;
        }
        
        #cameraContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 100;
        }
        
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #messageBox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 1001;
            display: none;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p>Loading 3D Robot Arm...</p>
    </div>
    
    <div id="container">
        <div id="threejs-container"></div>
        <div id="cameraContainer">
            <video id="cameraFeed" autoplay playsinline muted></video>
        </div>
    </div>
    
    <div id="messageBox"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <script>
        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            if (msgBox) {
                msgBox.textContent = message;
                msgBox.style.display = 'block';
                setTimeout(() => {
                    msgBox.style.display = 'none';
                }, duration);
            }
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // --- Socket.IO Setup ---
        const FLASK_SOCKET_URL = 'https://remote-character-control.onrender.com';
        console.log(`Mobile View: Connecting to: ${FLASK_SOCKET_URL}`);
        const socket = io(FLASK_SOCKET_URL);

        // --- Camera Setup ---
        let cameraStream = null;
        let cameraActive = false;

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'environment' // Use back camera if available
                    }
                });
                
                const video = document.getElementById('cameraFeed');
                video.srcObject = stream;
                cameraStream = stream;
                cameraActive = true;
                
                document.getElementById('cameraContainer').style.display = 'block';
                showMessage('Camera started', 2000);
                
                // Start sending frames
                sendCameraFrames();
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                showMessage('Camera access denied or not available', 3000);
            }
        }

        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraActive = false;
                
                const video = document.getElementById('cameraFeed');
                video.srcObject = null;
                
                document.getElementById('cameraContainer').style.display = 'none';
                showMessage('Camera stopped', 2000);
            }
        }

        function sendCameraFrames() {
            if (!cameraActive || !cameraStream) return;
            
            const video = document.getElementById('cameraFeed');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 240;
            
            function captureFrame() {
                if (!cameraActive) return;
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const dataURL = canvas.toDataURL('image/jpeg', 0.7);
                const base64 = dataURL.split(',')[1];
                
                socket.emit('mobile_camera_frame', { frame: base64 });
                
                setTimeout(captureFrame, 100); // Send frame every 100ms
            }
            
            // Wait for video to be ready
            video.addEventListener('loadeddata', () => {
                captureFrame();
            });
        }

        // --- Socket Events for Camera ---
        socket.on('start_camera', () => {
            console.log('Mobile View: Received start camera command');
            startCamera();
        });

        socket.on('stop_camera', () => {
            console.log('Mobile View: Received stop camera command');
            stopCamera();
        });

        // --- Three.js Setup ---
        let scene, camera, renderer, controls;
        let robotBaseGroup;
        let jointObjects = {};
        let linkObjects = {};

        const MAX_X_POSITION_CLIENT = 900;
        const URDF_SCALE = 50; // Reduced scale for smaller robot

        // STL Loader
        class STLLoader {
            load(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader();
                loader.setResponseType('arraybuffer');
                loader.load(url, (buffer) => {
                    const geometry = this.parse(buffer);
                    onLoad(geometry);
                }, onProgress, onError);
            }

            parse(buffer) {
                const dataView = new DataView(buffer);
                const isASCII = this.isASCII(buffer);
                
                return isASCII ? this.parseASCII(buffer) : this.parseBinary(dataView);
            }

            isASCII(buffer) {
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(buffer.slice(0, 80));
                return text.toLowerCase().includes('solid');
            }

            parseASCII(buffer) {
                // Simplified ASCII STL parser
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(buffer);
                const geometry = new THREE.BufferGeometry();
                
                // For demo, return a simple box geometry
                // In production, implement full ASCII STL parsing
                return new THREE.BoxGeometry(20, 20, 20);
            }

            parseBinary(dataView) {
                const triangles = dataView.getUint32(80, true);
                const vertices = [];
                const normals = [];
                
                for (let i = 0; i < triangles; i++) {
                    const offset = 84 + i * 50;
                    
                    // Normal
                    const nx = dataView.getFloat32(offset, true);
                    const ny = dataView.getFloat32(offset + 4, true);
                    const nz = dataView.getFloat32(offset + 8, true);
                    
                    // Vertices
                    for (let j = 0; j < 3; j++) {
                        const vertexOffset = offset + 12 + j * 12;
                        vertices.push(
                            dataView.getFloat32(vertexOffset, true),
                            dataView.getFloat32(vertexOffset + 4, true),
                            dataView.getFloat32(vertexOffset + 8, true)
                        );
                        normals.push(nx, ny, nz);
                    }
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                return geometry;
            }
        }

        function initThreeJS() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2c3e50);

                // Camera setup - adjusted for smaller robot
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 200; // Reduced for smaller view
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                     frustumSize * aspect / 2,
                     frustumSize / 2,
                    -frustumSize / 2,
                    1, 1000
                );
                camera.position.set(100, 100, 200);
                camera.lookAt(0, 25, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                const container = document.getElementById('threejs-container');
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                container.appendChild(renderer.domElement);

                // Enhanced lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);

                // Ground plane
                const planeGeometry = new THREE.PlaneGeometry(500, 500);
                const planeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x34495e,
                    transparent: true,
                    opacity: 0.8
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -0.1;
                plane.receiveShadow = true;
                scene.add(plane);

                createRobotFromURDF();
                
                window.addEventListener('resize', onWindowResize, false);
                
                animate();
                hideLoadingOverlay();
                showMessage("3D robot arm loaded successfully!", 3000);
                
            } catch (error) {
                console.error("Error initializing Three.js:", error);
                showMessage("Failed to load 3D robot arm: " + error.message, 5000);
            }
        }

        function createRobotFromURDF() {
            robotBaseGroup = new THREE.Group();
            
            // Materials
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x34495e,
                shininess: 100
            });
            const jointMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xe74c3c,
                shininess: 100
            });
            const linkMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3498db,
                shininess: 100
            });

            // Base link - scaled down
            const baseLinkGeo = new THREE.CylinderGeometry(15, 15, 20, 16);
            const baseLink = new THREE.Mesh(baseLinkGeo, baseMaterial);
            baseLink.position.set(0, 10, 0);
            baseLink.castShadow = true;
            baseLink.receiveShadow = true;
            linkObjects['base_link'] = baseLink;
            robotBaseGroup.add(baseLink);

            // Shoulder yaw joint
            const shoulderYawJointGroup = new THREE.Group();
            shoulderYawJointGroup.position.set(0, 20, 0);
            jointObjects['shoulder_yaw'] = shoulderYawJointGroup;
            baseLink.add(shoulderYawJointGroup);

            // Shoulder link
            const shoulderLinkGeo = new THREE.CylinderGeometry(8, 8, 15, 16);
            const shoulderLink = new THREE.Mesh(shoulderLinkGeo, jointMaterial);
            shoulderLink.castShadow = true;
            linkObjects['shoulder_link'] = shoulderLink;
            shoulderYawJointGroup.add(shoulderLink);

            // Shoulder pitch joint
            const shoulderPitchJointGroup = new THREE.Group();
            shoulderPitchJointGroup.position.set(0, 0, 8);
            jointObjects['shoulder_pitch'] = shoulderPitchJointGroup;
            shoulderLink.add(shoulderPitchJointGroup);

            // Bicep link
            const bicepLinkGeo = new THREE.BoxGeometry(8, 8, 40);
            const bicepLink = new THREE.Mesh(bicepLinkGeo, linkMaterial);
            bicepLink.position.set(0, 0, 20);
            bicepLink.castShadow = true;
            linkObjects['bicep_link'] = bicepLink;
            shoulderPitchJointGroup.add(bicepLink);

            // Elbow pitch joint
            const elbowPitchJointGroup = new THREE.Group();
            elbowPitchJointGroup.position.set(0, 0, 35);
            jointObjects['elbow_pitch'] = elbowPitchJointGroup;
            bicepLink.add(elbowPitchJointGroup);

            // Forearm link
            const forearmLinkGeo = new THREE.BoxGeometry(6, 6, 30);
            const forearmLink = new THREE.Mesh(forearmLinkGeo, linkMaterial);
            forearmLink.position.set(0, 0, 15);
            forearmLink.castShadow = true;
            linkObjects['forearm_link'] = forearmLink;
            elbowPitchJointGroup.add(forearmLink);

            // Wrist pitch joint
            const wristPitchJointGroup = new THREE.Group();
            wristPitchJointGroup.position.set(0, 0, 25);
            jointObjects['wrist_pitch'] = wristPitchJointGroup;
            forearmLink.add(wristPitchJointGroup);

            // Wrist 1
            const wrist1LinkGeo = new THREE.BoxGeometry(6, 6, 8);
            const wrist1Link = new THREE.Mesh(wrist1LinkGeo, jointMaterial);
            wrist1Link.castShadow = true;
            linkObjects['wrist_1'] = wrist1Link;
            wristPitchJointGroup.add(wrist1Link);

            // Wrist roll joint
            const wristRollJointGroup = new THREE.Group();
            wristRollJointGroup.position.set(0, 0, 6);
            jointObjects['wrist_roll'] = wristRollJointGroup;
            wrist1Link.add(wristRollJointGroup);

            // Wrist 2 (gripper base)
            const wrist2LinkGeo = new THREE.BoxGeometry(8, 8, 6);
            const wrist2Link = new THREE.Mesh(wrist2LinkGeo, baseMaterial);
            wrist2Link.castShadow = true;
            linkObjects['wrist_2'] = wrist2Link;
            wristRollJointGroup.add(wrist2Link);

            // Finger joints
            const finger1JointGroup = new THREE.Group();
            finger1JointGroup.position.set(4, 0, 4);
            jointObjects['finger_joint'] = finger1JointGroup;
            wrist2Link.add(finger1JointGroup);

            const finger2JointGroup = new THREE.Group();
            finger2JointGroup.position.set(-4, 0, 4);
            jointObjects['finger_joint_2'] = finger2JointGroup;
            wrist2Link.add(finger2JointGroup);

            // Finger links
            const fingerLinkGeo = new THREE.BoxGeometry(2, 2, 8);
            const finger1Link = new THREE.Mesh(fingerLinkGeo, jointMaterial);
            finger1Link.position.set(0, 0, 4);
            finger1Link.castShadow = true;
            linkObjects['finger_link_1'] = finger1Link;
            finger1JointGroup.add(finger1Link);

            const finger2Link = new THREE.Mesh(fingerLinkGeo, jointMaterial);
            finger2Link.position.set(0, 0, 4);
            finger2Link.castShadow = true;
            linkObjects['finger_link_2'] = finger2Link;
            finger2JointGroup.add(finger2Link);

            scene.add(robotBaseGroup);
            console.log("Robot created from URDF structure");
        }

        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('threejs-container');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 200;

            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;

            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Socket Events ---
        socket.on('character_moved', (position) => {
            if (!robotBaseGroup) return;
            const scaledX = position.x - (MAX_X_POSITION_CLIENT / 2);
            robotBaseGroup.position.x = scaledX;
            robotBaseGroup.position.y = position.y;
        });

        socket.on('gravity', (position) => {
            if (!robotBaseGroup) return;
            const startY = robotBaseGroup.position.y;
            const targetY = position.y;
            const duration = 300;
            const startTime = performance.now();

            function animateFall(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                robotBaseGroup.position.y = startY + (targetY - startY) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateFall);
                }
            }
            requestAnimationFrame(animateFall);
        });

        socket.on('initial_joint_states', (jointStates) => {
            for (const jointName in jointStates) {
                if (jointObjects.hasOwnProperty(jointName)) {
                    applyJointAngle(jointName, jointStates[jointName]);
                }
            }
        });

        socket.on('joint_angle_updated', (data) => {
            if (jointObjects.hasOwnProperty(data.joint_name)) {
                applyJointAngle(data.joint_name, data.angle);
            }
        });

        function applyJointAngle(jointName, angle) {
            const jointGroup = jointObjects[jointName];
            if (!jointGroup) return;

            switch (jointName) {
                case 'shoulder_yaw':
                    jointGroup.rotation.y = angle;
                    break;
                case 'shoulder_pitch':
                    jointGroup.rotation.x = angle;
                    break;
                case 'elbow_pitch':
                    jointGroup.rotation.x = angle;
                    break;
                case 'wrist_pitch':
                    jointGroup.rotation.x = angle;
                    break;
                case 'wrist_roll':
                    jointGroup.rotation.z = angle;
                    break;
                case 'finger_joint':
                    if (linkObjects['finger_link_1']) {
                        linkObjects['finger_link_1'].position.x = angle * 100;
                    }
                    if (linkObjects['finger_link_2']) {
                        linkObjects['finger_link_2'].position.x = -angle * 100;
                    }
                    break;
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initThreeJS();
        });

        // Socket connection events
        socket.on('connect', () => {
            console.log('Mobile View: Connected to server');
            showMessage('Connected to server', 2000);
        });

        socket.on('disconnect', () => {
            console.log('Mobile View: Disconnected from server');
            showMessage('Disconnected from server', 3000);
        });
    </script>
</body>
</html>