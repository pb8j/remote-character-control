<!DOCTYPE html>
<html>
<head>
    <title>Mobile View (3D Robot Arm)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background-color: #222; }
        canvas {
            display: block;
            background-color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }
        #messageBox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1001;
            display: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        /* Hidden video element for camera capture */
        #hiddenVideo {
            display: none;
        }
        #hiddenCanvas {
            display: none;
        }
    </style>
</head>
<body>
    <div id="threejs-container"></div>
    <div id="messageBox"></div>
    
    <!-- Hidden elements for camera capture -->
    <video id="hiddenVideo" autoplay muted playsinline></video>
    <canvas id="hiddenCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <script>
        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            if (msgBox) {
                msgBox.textContent = message;
                msgBox.style.display = 'block';
                setTimeout(() => {
                    msgBox.style.display = 'none';
                }, duration);
            } else {
                console.warn('MessageBox element not found!');
            }
        }

        // --- Camera Variables ---
        let cameraStream = null;
        let cameraInterval = null;
        const hiddenVideo = document.getElementById('hiddenVideo');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const hiddenContext = hiddenCanvas.getContext('2d');

        // --- Socket.IO Setup ---
        const FLASK_SOCKET_URL = 'https://remote-character-control.onrender.com';
        console.log(`Mobile View: Attempting to connect to Socket.IO at: ${FLASK_SOCKET_URL}`);
        const socket = io(FLASK_SOCKET_URL);

        // --- Three.js Setup ---
        let scene, camera, renderer;
        let robotBaseGroup; // This group will hold the entire robot for overall X/Y movement
        let jointObjects = {}; // To store references to THREE.Group objects representing joints
        let linkObjects = {}; // To store references to THREE.Mesh objects representing links

        const MAX_X_POSITION_CLIENT = 900; // Consistent with app.py
        const URDF_SCALE = 100; // 1 meter in URDF = 100 units in Three.js for visualization

        // Helper to convert URDF rpy (roll, pitch, yaw) to Three.js Euler angles
        function rpyToEuler(r, p, y) {
            return new THREE.Euler(r, p, y, 'XYZ'); // Order is important, XYZ is common default for RPY
        }

        function initThreeJS() {
            console.log("Mobile View: initThreeJS called.");
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x333333);
                console.log("Mobile View: Scene created.");

                // Camera - adjusted frustumSize and position for better view of an arm
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 400; // Increased to see more of the robot arm
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                     frustumSize * aspect / 2,
                     frustumSize / 2,
                    -frustumSize / 2,
                    1, 1000
                );
                camera.position.set(0, 100, 500); // Raise camera slightly, keep it far back
                camera.lookAt(0, 50, 0); // Look at the center of the base or lower part of the arm
                console.log("Mobile View: Camera created.");

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.9);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                const threejsContainer = document.getElementById('threejs-container');
                if (threejsContainer) {
                    threejsContainer.appendChild(renderer.domElement);
                    console.log("Mobile View: Renderer appended to container.");
                } else {
                    console.error('Mobile View: THREE.JS CRITICAL: Container #threejs-container NOT found!');
                    showMessage('3D scene failed: Missing container element.', 7000);
                    return;
                }

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);
                console.log("Mobile View: Lights added.");

                const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = Math.PI / 2;
                plane.position.y = -0.01; // Slightly below y=0 to avoid z-fighting with robot base if at y=0
                scene.add(plane);
                console.log("Mobile View: Ground plane added.");

                // --- DIAGNOSTIC TEST CUBE ---
                const testCubeGeo = new THREE.BoxGeometry(100, 100, 100);
                const testCubeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Bright green
                const testCube = new THREE.Mesh(testCubeGeo, testCubeMat);
                testCube.position.set(0, 50, 0); // Position at center, half height above ground
                scene.add(testCube);
                console.log("Mobile View: Added diagnostic test cube.");
                // --- END DIAGNOSTIC TEST CUBE ---


                createReactorRobot();
                console.log("Mobile View: Reactor robot created.");

                window.addEventListener('resize', onWindowResize, false);
                console.log("Mobile View: Resize listener added.");

                animate();
                console.log("Mobile View: Animation loop started.");
                showMessage("3D robot arm loaded!", 3000);
            } catch (error) {
                console.error("Mobile View: CRITICAL ERROR initializing Three.js:", error);
                showMessage("Failed to load 3D robot arm: " + error.message, 10000);
            }
        }


        // --- Function to create the Reactor Robot from primitives, mimicking URDF structure ---
        function createReactorRobot() {
            console.log("Mobile View: createReactorRobot called.");

            robotBaseGroup = new THREE.Group(); // This group represents the overall robot's position
            // scene.add(robotBaseGroup); // Add to scene later, after testCube is verified

            // Materials (define once to reuse)
            const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 }); // Dark gray
            const highlightMaterial = new THREE.MeshPhongMaterial({ color: 0xA0A0A0 }); // Lighter gray for joints/details
            const jointAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }); // Green for axis debug

            // Link: base_link
            // URDF: box size="0.1 0.1 0.15" (10cm x 10cm x 15cm)
            const baseLinkGeo = new THREE.CylinderGeometry(50, 50, 80, 32); // Radius 50 (100mm dia), height 80 (8cm)
            const baseLink = new THREE.Mesh(baseLinkGeo, defaultMaterial);
            baseLink.position.set(0, 40, 0); // Center of mesh is 0,0,0. Move up by half height to sit on Y=0
            linkObjects['base_link'] = baseLink;
            robotBaseGroup.add(baseLink);

            // Joint: shoulder_yaw (revolute, axis z)
            // origin xyz="0 0 0.081" relative to base_link
            const shoulderYawJointGroup = new THREE.Group();
            shoulderYawJointGroup.position.set(0, 81, 0); // 81 units (mm) above base_link's center (0,40,0) (so relative to scene's Y=0, it's 40+81=121)
            jointObjects['shoulder_yaw'] = shoulderYawJointGroup;
            baseLink.add(shoulderYawJointGroup); // Attach to base link


            // Link: shoulder_link
            // Attached to shoulder_yaw joint. Its origin in URDF is 0 0 0 relative to joint.
            const shoulderLinkGeo = new THREE.CylinderGeometry(30, 30, 40, 32); // Approx shoulder piece, height along Y
            const shoulderLink = new THREE.Mesh(shoulderLinkGeo, defaultMaterial);
            shoulderLink.position.set(0, 0, 0); // Position relative to its parent jointGroup
            linkObjects['shoulder_link'] = shoulderLink;
            shoulderYawJointGroup.add(shoulderLink);


            // Joint: shoulder_pitch (revolute, axis y)
            // origin xyz="0 0 0.0265" relative to shoulder_link
            const shoulderPitchJointGroup = new THREE.Group();
            shoulderPitchJointGroup.position.set(0, 0, 26.5); // 26.5mm along Z from shoulder_link's center
            jointObjects['shoulder_pitch'] = shoulderPitchJointGroup;
            shoulderLink.add(shoulderPitchJointGroup);

            // Link: bicep_link
            // Attached to shoulder_pitch joint. URDF has offset: xyz="-0.079312 0.00175 0.0073486"
            const bicepLinkGeo = new THREE.BoxGeometry(40, 40, 150); // Approx bicep, Z is length
            const bicepLink = new THREE.Mesh(bicepLinkGeo, defaultMaterial);
            // Apply mesh offset from URDF origin to keep visual centered on link's actual geometry
            bicepLink.position.set(
                -0.079312 * URDF_SCALE,
                0.00175 * URDF_SCALE,
                (150 / 2) + (0.0073486 * URDF_SCALE) // half length + URDF Z offset
            );
            // Orient bicep along what will be its length axis after joint rotations
            bicepLink.rotation.y = Math.PI / 2; // Rotate it to be horizontal for pitching
            linkObjects['bicep_link'] = bicepLink;
            shoulderPitchJointGroup.add(bicepLink);


            // Joint: elbow_pitch (revolute, axis y)
            // origin xyz="-0.1445 0 0.0385" relative to bicep_link
            const elbowPitchJointGroup = new THREE.Group();
            elbowPitchJointGroup.position.set(
                (-0.1445 * URDF_SCALE),
                (0 * URDF_SCALE), // Assuming 0 Y offset
                (0.0385 * URDF_SCALE)
            );
            jointObjects['elbow_pitch'] = elbowPitchJointGroup;
            bicepLink.add(elbowPitchJointGroup);

            // Link: forearm_link
            // Attached to elbow_pitch joint.
            // FIX: Defined forearmLinkGeo here
            const forearmLinkGeo = new THREE.BoxGeometry(30, 30, 130);
            const forearmLink = new THREE.Mesh(forearmLinkGeo, defaultMaterial); // FIX: Changed forearmGeo to forearmLinkGeo
            forearmLink.position.set(0, 0, 130/2); // Half length along local Z
            linkObjects['forearm_link'] = forearmLink;
            elbowPitchJointGroup.add(forearmLink);


            // Joint: wrist_pitch (revolute, axis y)
            // origin xyz="0.1535 0 0" relative to forearm_link
            const wristPitchJointGroup = new THREE.Group();
            wristPitchJointGroup.position.set(153.5, 0, 0); // 153.5mm along X from forearm_link end
            jointObjects['wrist_pitch'] = wristPitchJointGroup;
            forearmLink.add(wristPitchJointGroup);

            // Link: wrist_1
            // Attached to wrist_pitch joint.
            const wrist1LinkGeo = new THREE.BoxGeometry(30, 30, 30);
            const wrist1Link = new THREE.Mesh(wrist1LinkGeo, defaultMaterial);
            wrist1Link.position.set(0,0,0);
            linkObjects['wrist_1'] = wrist1Link;
            wristPitchJointGroup.add(wrist1Link);


            // Joint: wrist_roll (revolute, axis x)
            // origin xyz="0.071 0.00175 0" relative to wrist_1
            const wristRollJointGroup = new THREE.Group();
            wristRollJointGroup.position.set(71, 0, 0); // 71mm along X from wrist_1 center
            jointObjects['wrist_roll'] = wristRollJointGroup;
            wrist1Link.add(wristRollJointGroup);

            // Link: wrist_2 (gripper base)
            // Attached to wrist_roll joint.
            const wrist2LinkGeo = new THREE.BoxGeometry(35, 35, 35);
            const wrist2Link = new THREE.Mesh(wrist2LinkGeo, defaultMaterial);
            wrist2Link.position.set(0,0,0);
            linkObjects['wrist_2'] = wrist2Link;
            wristRollJointGroup.add(wrist2Link);


            // Joint: finger_joint (Prismatic, axis z)
            // origin xyz="0.088882 -0.0187500 0.0012072" relative to wrist_2
            // rpy="1.5708 -1.5572 -3.1416"
            const finger1JointGroup = new THREE.Group();
            finger1JointGroup.position.set(88.882, -18.75, 1.2072);
            finger1JointGroup.rotation.set(1.5708, -1.5572, -3.1416); // Apply RPY rotation
            jointObjects['finger_joint'] = finger1JointGroup;
            wrist2Link.add(finger1JointGroup);

            // Link: finger_link_1 (moves with finger_joint)
            const fingerLinkGeo = new THREE.BoxGeometry(10, 10, 50); // Small, thin finger part, length along Z
            const finger1Link = new THREE.Mesh(fingerLinkGeo, highlightMaterial);
            finger1Link.position.set(0, 0, 25); // Half length along local Z of joint
            linkObjects['finger_link_1'] = finger1Link;
            finger1JointGroup.add(finger1Link);


            // Joint: finger_joint_2 (Prismatic, mimics finger_joint)
            // origin xyz="0.088882 0.0187500 0.0012072" relative to wrist_2
            // rpy="1.5708 1.5572 -1.4508E-15"
            const finger2JointGroup = new THREE.Group();
            finger2JointGroup.position.set(88.882, 18.75, 1.2072);
            finger2JointGroup.rotation.set(1.5708, 1.5572, -1.4508e-15); // Apply RPY rotation
            jointObjects['finger_joint_2'] = finger2JointGroup;
            wrist2Link.add(finger2JointGroup);

            // Link: finger_link_2 (moves with finger_joint_2)
            const finger2Link = new THREE.Mesh(fingerLinkGeo, highlightMaterial);
            finger2Link.position.set(0, 0, 25); // Half length along local Z of joint
            linkObjects['finger_link_2'] = finger2Link;
            finger2JointGroup.add(finger2Link);

            // Add the entire robot group to the scene after all parts are assembled
            scene.add(robotBaseGroup);
            console.log("Mobile View: Robot arm assembled with primitives and added to scene.");
            console.log("Mobile View: jointObjects:", jointObjects);
        }

        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            } else {
                console.warn("Mobile View: Renderer, scene, or camera not fully initialized for animation. Stopping animate loop.");
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 400;

            camera.left   = -frustumSize * aspect / 2;
            camera.right  =  frustumSize * aspect / 2;
            camera.top    =  frustumSize / 2;
            camera.bottom = -frustumSize / 2;

            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.9);
            console.log(`Mobile View: Window resized: Renderer set to ${renderer.domElement.width}x${renderer.domElement.height}`);
        }

        // --- Camera Functions ---
        async function startCamera() {
            try {
                console.log("Mobile View: Requesting camera access...");
                showMessage("Starting camera...", 2000);
                
                const constraints = {
                    video: {
                        facingMode: 'environment', // Use back camera if available
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                hiddenVideo.srcObject = cameraStream;
                
                hiddenVideo.onloadedmetadata = () => {
                    hiddenCanvas.width = hiddenVideo.videoWidth;
                    hiddenCanvas.height = hiddenVideo.videoHeight;
                    
                    console.log(`Mobile View: Camera started - ${hiddenVideo.videoWidth}x${hiddenVideo.videoHeight}`);
                    showMessage("Camera active - streaming to control panel", 3000);
                    
                    // Start sending frames
                    cameraInterval = setInterval(captureAndSendFrame, 100); // 10 FPS
                };
                
            } catch (error) {
                console.error("Mobile View: Camera access failed:", error);
                showMessage("Camera access denied or failed", 5000);
            }
        }

        function stopCamera() {
            console.log("Mobile View: Stopping camera...");
            
            if (cameraInterval) {
                clearInterval(cameraInterval);
                cameraInterval = null;
            }
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            hiddenVideo.srcObject = null;
            showMessage("Camera stopped", 2000);
        }

        function captureAndSendFrame() {
            if (!hiddenVideo.videoWidth || !hiddenVideo.videoHeight) return;
            
            try {
                // Draw current video frame to canvas
                hiddenContext.drawImage(hiddenVideo, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                
                // Convert to base64 JPEG
                const dataURL = hiddenCanvas.toDataURL('image/jpeg', 0.7);
                const base64Data = dataURL.split(',')[1];
                
                // Send to server via WebSocket
                socket.emit('mobile_camera_frame', { frame: base64Data });
                
            } catch (error) {
                console.error("Mobile View: Error capturing camera frame:", error);
            }
        }

        // --- Character Base Movement Sync (for overall robot position) ---
        socket.on('character_moved', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when character_moved received.");
                return;
            }
            const scaledX = position.x - (MAX_X_POSITION_CLIENT / 2);
            const scaledY = position.y; 
            // baseLink is at Y=40, so its bottom is at Y=0.
            // If character_position['y'] is the desired base height from the ground,
            // then robotBaseGroup should be at that height.
            // Adjust the 40 for half height of baseLink (if baseLinkGeo is 80 height, center is 40).
            robotBaseGroup.position.x = scaledX;
            // FIX: Changed baseLinkObjects to linkObjects for consistency and to match variable name
            robotBaseGroup.position.y = scaledY + (linkObjects['base_link'] ? linkObjects['base_link'].geometry.parameters.height / 2 : 40);
            console.log(`Mobile View: Robot base moved (server pos: ${position.x},${position.y}) -> (3D pos: ${robotBaseGroup.position.x.toFixed(2)},${robotBaseGroup.position.y.toFixed(2)})`);
        });

        socket.on('gravity', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when gravity received.");
                return;
            }
            const targetY = position.y + (linkObjects['base_link'] ? linkObjects['base_link'].geometry.parameters.height / 2 : 40); // Match offset

            const startY = robotBaseGroup.position.y;
            const duration = 300;
            const startTime = performance.now();

            function animateFall(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                robotBaseGroup.position.y = startY + (targetY - startY) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    robotBaseGroup.position.y = targetY;
                }
            }
            requestAnimationFrame(animateFall);
            console.log(`Mobile View: Gravity applied. Falling to Y: ${targetY}`);
        });

        // --- Camera Control Socket Events ---
        socket.on('start_camera', () => {
            console.log("Mobile View: Received start camera command from server");
            startCamera();
        });

        socket.on('stop_camera', () => {
            console.log("Mobile View: Received stop camera command from server");
            stopCamera();
        });

        // --- Socket Event for Joint Angle Updates ---
        socket.on('initial_joint_states', (jointStates) => {
            console.log('Mobile View: Received initial joint states:', jointStates);
            for (const jointName in jointStates) {
                if (jointObjects.hasOwnProperty(jointName)) {
                    applyJointAngle(jointName, jointStates[jointName]);
                } else {
                    console.warn(`Mobile View: Initial state for unknown joint received: ${jointName}`);
                }
            }
        });

        socket.on('joint_angle_updated', (data) => {
            console.log(`Mobile View: Received joint update: ${data.joint_name}, angle: ${data.angle}`);
            if (jointObjects.hasOwnProperty(data.joint_name)) {
                applyJointAngle(data.joint_name, data.angle);
            } else {
                console.warn(`Mobile View: Update for unknown joint received: ${data.joint_name}`);
            }
        });

        // --- Function to apply joint angles to Three.js objects ---
        function applyJointAngle(jointName, angle) {
            const jointGroup = jointObjects[jointName];
            if (!jointGroup) {
                console.error(`Mobile View: Attempted to move non-existent joint group: ${jointName}`);
                return;
            }

            switch (jointName) {
                case 'shoulder_yaw':
                    jointGroup.rotation.z = angle;
                    break;
                case 'shoulder_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'elbow_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'wrist_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'wrist_roll':
                    jointGroup.rotation.x = angle;
                    break;
                case 'finger_joint':
                    // Prismatic joint: moves the finger links along their local Z axis
                    if (linkObjects['finger_link_1']) {
                        linkObjects['finger_link_1'].position.z = angle * URDF_SCALE;
                    }
                    if (linkObjects['finger_link_2']) {
                        linkObjects['finger_link_2'].position.z = -angle * URDF_SCALE; // Move second finger in opposite direction
                    }
                    break;
                case 'finger_joint_2': // Mimics finger_joint, handled by finger_joint case
                    break;
                default:
                    console.warn(`Mobile View: No direct application for joint: ${jointName}`);
            }
            renderer.render(scene, camera); // Re-render after joint change
        }

        // --- Socket Connection Events ---
        socket.on('connect', () => {
            console.log('Mobile View: Connected to Flask SocketIO. Socket ID:', socket.id);
        });

        socket.on('disconnect', (reason) => {
            console.log('Mobile View: Disconnected from Flask SocketIO. Reason:', reason);
            // Stop camera if disconnected
            if (cameraInterval) {
                stopCamera();
            }
        });

        socket.on('connect_error', (err) => {
            console.error('Mobile View: Socket.IO Connection Error:', err.message, err.description);
        });

        document.addEventListener('DOMContentLoaded', function() {
            console.log("Mobile View: DOMContentLoaded event fired. Initializing Three.js...");
            initThreeJS();
        });

    </script>

</body>
</html>