<!DOCTYPE html>
<html>
<head>
    <title>Mobile View (3D Robot Arm)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background-color: #222; }
        canvas {
            display: block;
            background-color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }
        #messageBox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1001;
            display: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="threejs-container"></div>
    <div id="messageBox"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <!-- Include STLLoader from Three.js examples -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            if (msgBox) {
                msgBox.textContent = message;
                msgBox.style.display = 'block';
                setTimeout(() => {
                    msgBox.style.display = 'none';
                }, duration);
            } else {
                console.warn('MessageBox element not found!');
            }
        }

        // --- Socket.IO Setup ---
        const FLASK_SOCKET_URL = 'https://remote-character-control.onrender.com';
        console.log(`Mobile View: Attempting to connect to Socket.IO at: ${FLASK_SOCKET_URL}`);
        const socket = io(FLASK_SOCKET_URL);

        // --- Three.js Setup ---
        let scene, camera, renderer;
        let robotBaseGroup; // This group will hold the entire robot for overall X/Y movement
        let jointObjects = {}; // To store references to THREE.Group objects representing joints
        let linkObjects = {}; // To store references to THREE.Mesh objects representing links

        const MAX_X_POSITION_CLIENT = 900; // Consistent with app.py
        const URDF_SCALE = 1000; // URDF typically uses meters. If your models are in mm, use 1. If in meters, use 1000 for mm.
                                 // A 10cm x 10cm x 15cm base_link would be 100x100x150 in mm.
                                 // Adjust this scale to fit your scene and model export units.

        // Helper to convert URDF rpy (roll, pitch, yaw) to Three.js Euler angles
        function rpyToEuler(r, p, y) {
            // URDF rpy is roll, pitch, yaw. Three.js Euler constructor is (x, y, z) corresponding to roll, pitch, yaw
            // The default order 'XYZ' is common for URDF.
            return new THREE.Euler(r, p, y, 'XYZ');
        }

        // --- Model Loading Helper ---
        function loadSTL(path, material = new THREE.MeshPhongMaterial({ color: 0x606060 })) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.STLLoader();
                loader.load(
                    path,
                    function (geometry) {
                        const mesh = new THREE.Mesh(geometry, material);
                        resolve(mesh);
                    },
                    function (xhr) {
                        // console.log((xhr.loaded / xhr.total * 100).toFixed(2) + '% loaded: ' + path);
                    },
                    function (error) {
                        console.error('An error occurred loading STL:', path, error);
                        reject(error);
                    }
                );
            });
        }

        async function initThreeJS() {
            console.log("Mobile View: initThreeJS called.");
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x333333);
                console.log("Mobile View: Scene created.");

                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 400; // Increased to see more of the robot arm
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                     frustumSize * aspect / 2,
                     frustumSize / 2,
                    -frustumSize / 2,
                    1, 1000
                );
                camera.position.set(0, 200, 500); // Raise camera higher to view arm
                camera.lookAt(0, 100, 0); // Look at the base of the arm
                console.log("Mobile View: Camera created.");

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.9);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                const threejsContainer = document.getElementById('threejs-container');
                if (threejsContainer) {
                    threejsContainer.appendChild(renderer.domElement);
                    console.log("Mobile View: Renderer appended to container.");
                } else {
                    console.error('Mobile View: THREE.JS CRITICAL: Container #threejs-container NOT found!');
                    showMessage('3D scene failed: Missing container element.', 7000);
                    return;
                }

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);
                console.log("Mobile View: Lights added.");

                const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = Math.PI / 2;
                plane.position.y = -0.01; // Slightly below y=0
                scene.add(plane);
                console.log("Mobile View: Ground plane added.");

                showMessage("Loading robot model, please wait...");
                await createReactorRobot(); // <--- AWAIT THE ASYNC FUNCTION
                console.log("Mobile View: Reactor robot created.");

                window.addEventListener('resize', onWindowResize, false);
                console.log("Mobile View: Resize listener added.");

                animate();
                console.log("Mobile View: Animation loop started.");
                showMessage("3D robot arm loaded and ready!", 3000);
            } catch (error) {
                console.error("Mobile View: CRITICAL ERROR initializing Three.js:", error);
                showMessage("Failed to load 3D scene or robot: " + error.message, 10000);
            }
        }


        // --- NEW: Function to create the Reactor Robot by loading STL meshes ---
        async function createReactorRobot() {
            console.log("Mobile View: createReactorRobot called.");

            robotBaseGroup = new THREE.Group(); // This group represents the overall robot's position
            scene.add(robotBaseGroup);

            // Define materials
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark gray
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 }); // Medium gray
            const gripperMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Light gray

            // --- Load Links and Build Hierarchy ---
            // The URDF "package://" path needs to be mapped to a real HTTP path.
            // Assuming your STL files are in a 'static/meshes' folder on Render.
            const STL_BASE_PATH = '/static/meshes/'; // <<< ADJUST THIS PATH IF YOUR MESHES ARE ELSEWHERE

            try {
                // Link: base_link
                const baseLinkMesh = await loadSTL(STL_BASE_PATH + 'base_link.STL', baseMaterial);
                baseLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE); // Apply global scale
                // Adjust baseLinkMesh position relative to its own loaded geometry if its origin isn't at 0,0,0 (bottom-center)
                // If it's exported with its origin at its center, then position.y = half its height to sit on the plane
                // For a base of 15cm height in URDF, if origin is its center, it needs to be 0.075 * URDF_SCALE up
                // Or: if your STL origin is already at the bottom center, just set position to 0,0,0
                baseLinkMesh.position.set(0, 0, 0); // Start at group's origin
                linkObjects['base_link'] = baseLinkMesh;
                robotBaseGroup.add(baseLinkMesh);


                // Joint: shoulder_yaw (revolute, axis z)
                // origin xyz="0 0 0.081" relative to base_link
                const shoulderYawJointGroup = new THREE.Group();
                shoulderYawJointGroup.position.set(0 * URDF_SCALE, 0 * URDF_SCALE, 0.081 * URDF_SCALE); // Position relative to base_link
                jointObjects['shoulder_yaw'] = shoulderYawJointGroup;
                baseLinkMesh.add(shoulderYawJointGroup); // Attach to base_link mesh


                // Link: shoulder_link
                const shoulderLinkMesh = await loadSTL(STL_BASE_PATH + 'shoulder_link.STL', armMaterial);
                shoulderLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // Adjust position/rotation relative to shoulderYawJointGroup if needed for model alignment
                shoulderLinkMesh.position.set(0,0,0);
                linkObjects['shoulder_link'] = shoulderLinkMesh;
                shoulderYawJointGroup.add(shoulderLinkMesh);


                // Joint: shoulder_pitch (revolute, axis y)
                // origin xyz="0 0 0.0265" relative to shoulder_link
                const shoulderPitchJointGroup = new THREE.Group();
                shoulderPitchJointGroup.position.set(0 * URDF_SCALE, 0 * URDF_SCALE, 0.0265 * URDF_SCALE);
                jointObjects['shoulder_pitch'] = shoulderPitchJointGroup;
                shoulderLinkMesh.add(shoulderPitchJointGroup);


                // Link: bicep_link
                const bicepLinkMesh = await loadSTL(STL_BASE_PATH + 'bicep_link.STL', armMaterial);
                bicepLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="-0.079312 0.00175 0.0073486" relative to shoulder_pitch joint
                bicepLinkMesh.position.set(-0.079312 * URDF_SCALE, 0.00175 * URDF_SCALE, 0.0073486 * URDF_SCALE);
                linkObjects['bicep_link'] = bicepLinkMesh;
                shoulderPitchJointGroup.add(bicepLinkMesh);


                // Joint: elbow_pitch (revolute, axis y)
                // origin xyz="-0.1445 0 0.0385" relative to bicep_link
                const elbowPitchJointGroup = new THREE.Group();
                elbowPitchJointGroup.position.set(-0.1445 * URDF_SCALE, 0 * URDF_SCALE, 0.0385 * URDF_SCALE);
                jointObjects['elbow_pitch'] = elbowPitchJointGroup;
                bicepLinkMesh.add(elbowPitchJointGroup);


                // Link: forearm_link
                const forearmLinkMesh = await loadSTL(STL_BASE_PATH + 'forearm_link.STL', armMaterial);
                forearmLinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to elbow_pitch joint
                forearmLinkMesh.position.set(0, 0, 0);
                linkObjects['forearm_link'] = forearmLinkMesh;
                elbowPitchJointGroup.add(forearmLinkMesh);


                // Joint: wrist_pitch (revolute, axis y)
                // origin xyz="0.1535 0 0" relative to forearm_link
                const wristPitchJointGroup = new THREE.Group();
                wristPitchJointGroup.position.set(0.1535 * URDF_SCALE, 0 * URDF_SCALE, 0 * URDF_SCALE);
                jointObjects['wrist_pitch'] = wristPitchJointGroup;
                forearmLinkMesh.add(wristPitchJointGroup);


                // Link: wrist_1
                const wrist1LinkMesh = await loadSTL(STL_BASE_PATH + 'wrist_1.STL', armMaterial);
                wrist1LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to wrist_pitch joint
                wrist1LinkMesh.position.set(0, 0, 0);
                linkObjects['wrist_1'] = wrist1LinkMesh;
                wristPitchJointGroup.add(wrist1LinkMesh);


                // Joint: wrist_roll (revolute, axis x)
                // origin xyz="0.071 0.00175 0" relative to wrist_1
                const wristRollJointGroup = new THREE.Group();
                wristRollJointGroup.position.set(0.071 * URDF_SCALE, 0.00175 * URDF_SCALE, 0 * URDF_SCALE);
                jointObjects['wrist_roll'] = wristRollJointGroup;
                wrist1LinkMesh.add(wristRollJointGroup);


                // Link: wrist_2 (gripper base)
                const wrist2LinkMesh = await loadSTL(STL_BASE_PATH + 'wrist_2.STL', gripperMaterial);
                wrist2LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                // origin xyz="0 0 0" relative to wrist_roll joint
                wrist2LinkMesh.position.set(0, 0, 0);
                linkObjects['wrist_2'] = wrist2LinkMesh;
                wristRollJointGroup.add(wrist2LinkMesh);


                // Joint: finger_joint (Prismatic, axis z)
                // origin xyz="0.088882 -0.0187500 0.0012072" relative to wrist_2
                // rpy="1.5708 -1.5572 -3.1416"
                const finger1JointGroup = new THREE.Group();
                finger1JointGroup.position.set(0.088882 * URDF_SCALE, -0.0187500 * URDF_SCALE, 0.0012072 * URDF_SCALE);
                finger1JointGroup.rotation.copy(rpyToEuler(1.5708, -1.5572, -3.1416));
                jointObjects['finger_joint'] = finger1JointGroup;
                wrist2LinkMesh.add(finger1JointGroup);

                // Link: finger_link_1
                const finger1LinkMesh = await loadSTL(STL_BASE_PATH + 'finger_link.STL', gripperMaterial); // Reusing finger_link for both
                finger1LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                finger1LinkMesh.position.set(0,0,0); // This position will be translated by applyJointAngle
                linkObjects['finger_link_1'] = finger1LinkMesh;
                finger1JointGroup.add(finger1LinkMesh);


                // Joint: finger_joint_2 (Prismatic, mimics finger_joint)
                // origin xyz="0.088882 0.0187500 0.0012072" relative to wrist_2
                // rpy="1.5708 1.5572 -1.4508E-15"
                const finger2JointGroup = new THREE.Group();
                finger2JointGroup.position.set(0.088882 * URDF_SCALE, 0.0187500 * URDF_SCALE, 0.0012072 * URDF_SCALE);
                finger2JointGroup.rotation.copy(rpyToEuler(1.5708, 1.5572, -1.4508e-15));
                jointObjects['finger_joint_2'] = finger2JointGroup;
                wrist2LinkMesh.add(finger2JointGroup);

                // Link: finger_link_2
                const finger2LinkMesh = await loadSTL(STL_BASE_PATH + 'finger_link.STL', gripperMaterial);
                finger2LinkMesh.scale.set(URDF_SCALE, URDF_SCALE, URDF_SCALE);
                finger2LinkMesh.position.set(0,0,0); // This position will be translated by applyJointAngle
                linkObjects['finger_link_2'] = finger2LinkMesh;
                finger2JointGroup.add(finger2LinkMesh);

                console.log("Mobile View: All robot parts loaded and assembled.");
                console.log("Mobile View: jointObjects:", jointObjects);
                console.log("Mobile View: linkObjects:", linkObjects);

            } catch (error) {
                console.error("Mobile View: Error assembling robot:", error);
                showMessage("Error assembling robot. Check console for missing STL files.", 10000);
            }
        }

        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            } else {
                console.warn("Mobile View: Renderer, scene, or camera not fully initialized for animation. Stopping animate loop.");
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 400;

            camera.left   = -frustumSize * aspect / 2;
            camera.right  =  frustumSize * aspect / 2;
            camera.top    =  frustumSize / 2;
            camera.bottom = -frustumSize / 2;

            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.9);
            console.log(`Mobile View: Window resized: Renderer set to ${renderer.domElement.width}x${renderer.domElement.height}`);
        }

        // --- Character Base Movement Sync (for overall robot position) ---
        socket.on('character_moved', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when character_moved received. Model might still be loading.");
                return;
            }
            const scaledX = position.x - (MAX_X_POSITION_CLIENT / 2);
            const scaledY = position.y; 
            // Position the robot base at the ground plane level
            robotBaseGroup.position.x = scaledX;
            robotBaseGroup.position.y = scaledY; // Y position on ground
            console.log(`Mobile View: Robot base moved (server pos: ${position.x},${position.y}) -> (3D pos: ${robotBaseGroup.position.x.toFixed(2)},${robotBaseGroup.position.y.toFixed(2)})`);
        });

        socket.on('gravity', (position) => {
            if (!robotBaseGroup) {
                console.warn("Mobile View: robotBaseGroup not initialized when gravity received. Model might still be loading.");
                return;
            }
            const targetY = position.y; // Target Y position for the base

            const startY = robotBaseGroup.position.y;
            const duration = 300;
            const startTime = performance.now();

            function animateFall(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                robotBaseGroup.position.y = startY + (targetY - startY) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    robotBaseGroup.position.y = targetY;
                }
            }
            requestAnimationFrame(animateFall);
            console.log(`Mobile View: Gravity applied. Falling to Y: ${targetY}`);
        });


        // --- Socket Event for Joint Angle Updates ---
        socket.on('initial_joint_states', (jointStates) => {
            console.log('Mobile View: Received initial joint states:', jointStates);
            for (const jointName in jointStates) {
                if (jointObjects.hasOwnProperty(jointName)) {
                    applyJointAngle(jointName, jointStates[jointName]);
                } else {
                    console.warn(`Mobile View: Initial state for unknown joint received: ${jointName}`);
                }
            }
        });

        socket.on('joint_angle_updated', (data) => {
            console.log(`Mobile View: Received joint update: ${data.joint_name}, angle: ${data.angle}`);
            if (jointObjects.hasOwnProperty(data.joint_name)) {
                applyJointAngle(data.joint_name, data.angle);
            } else {
                console.warn(`Mobile View: Update for unknown joint received: ${data.joint_name}`);
            }
        });

        // --- Function to apply joint angles to Three.js objects ---
        function applyJointAngle(jointName, angle) {
            const jointGroup = jointObjects[jointName];
            if (!jointGroup) {
                console.error(`Mobile View: Attempted to move non-existent joint group: ${jointName}`);
                return;
            }

            switch (jointName) {
                case 'shoulder_yaw':
                    jointGroup.rotation.z = angle;
                    break;
                case 'shoulder_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'elbow_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'wrist_pitch':
                    jointGroup.rotation.y = angle;
                    break;
                case 'wrist_roll':
                    jointGroup.rotation.x = angle;
                    break;
                case 'finger_joint':
                    // Prismatic joint: moves the finger links along their local Z axis
                    // The 'angle' value is a linear position (0 to 0.014m in URDF)
                    if (linkObjects['finger_link_1']) {
                        // This moves the finger mesh along its local Z-axis (as defined by finger1JointGroup's orientation)
                        linkObjects['finger_link_1'].position.z = angle * URDF_SCALE;
                    }
                    if (linkObjects['finger_link_2']) {
                        // The other finger moves in the opposite direction
                        linkObjects['finger_link_2'].position.z = -angle * URDF_SCALE;
                    }
                    break;
                case 'finger_joint_2': // Mimics finger_joint, handled by finger_joint case
                    break;
                default:
                    console.warn(`Mobile View: No direct application for joint: ${jointName}`);
            }
            renderer.render(scene, camera); // Re-render after joint change
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log("Mobile View: DOMContentLoaded event fired. Initializing Three.js...");
            initThreeJS();
        });

    </script>

</body>
</html>
